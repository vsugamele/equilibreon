import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter
} from "../ui/dialog";
import { ScrollArea } from "../ui/scroll-area";
import { Badge } from "../ui/badge";
import { Clock, Check } from "lucide-react";
import { format } from "date-fns";
import CalorieAnalyzer from "./CalorieAnalyzer";
import { addConsumedCalories } from "@/services/calorieService";
import { toast } from "sonner";
import foodHistoryService from "@/services/foodHistoryService";

// Fun√ß√µes de depura√ß√£o tempor√°rias 
// Verifica se estamos em desenvolvimento
const isDev = process.env.NODE_ENV !== 'production';

const debugLog = (title: string, data: any, showInProduction = false) => {
  if (isDev || showInProduction) {
    console.log(`DEBUG: ${title}`, data);
  }
};

const trackDebugEvent = (category: string, event: string, data: any = {}) => {
  if (!isDev && !data.critical) return;
  
  console.log(`DEBUG EVENT [${category}]: ${event}`, data);
  try {
    // Salvar no localStorage para refer√™ncia
    const debugKey = `debug_${category}_${event}_${Date.now()}`;
    localStorage.setItem(debugKey, JSON.stringify({
      timestamp: new Date().toISOString(),
      data
    }));
  } catch (e) {
    console.error('Erro ao salvar evento de debug:', e);
  }
};

const createDebugButton = () => {
  if (!isDev) return;
  
  // Verificar se o bot√£o j√° existe
  if (document.getElementById('debug-button')) return;
  
  // Criar bot√£o de depura√ß√£o flutuante
  const button = document.createElement('button');
  button.id = 'debug-button';
  button.innerText = 'üîç Debug';
  button.style.position = 'fixed';
  button.style.bottom = '20px';
  button.style.right = '20px';
  button.style.zIndex = '9999';
  button.style.padding = '8px 12px';
  button.style.background = '#333';
  button.style.color = '#bada55';
  button.style.border = 'none';
  button.style.borderRadius = '4px';
  button.style.cursor = 'pointer';
  
  // Ao clicar, mostra todos os dados de depura√ß√£o no console
  button.addEventListener('click', () => {
    console.log('üìä DADOS DE DEPURA√á√ÉO:');
    
    // Filtrar as chaves do localStorage para obter apenas as de depura√ß√£o
    const debugKeys = Object.keys(localStorage).filter(key => key.startsWith('debug_'));
    
    // Mostrar cada categoria de dados
    debugKeys.forEach(key => {
      try {
        const value = JSON.parse(localStorage.getItem(key) || '{}');
        console.log(`${key.replace('debug_', '')}:`, value);
      } catch (e) {
        console.log(`${key.replace('debug_', '')}:`, localStorage.getItem(key));
      }
    });
  });
  
  // Adicionar o bot√£o ao documento
  document.body.appendChild(button);
};

// Defini√ß√£o tempor√°ria do tipo NutritionData se n√£o estiver dispon√≠vel
interface FoodItem {
  name: string;
  calories?: number;
  portion?: string;
}

interface NutritionData {
  calories?: number;
  protein?: number;
  carbs?: number;
  fat?: number;
  
  confidence?: number;
  foodItems?: FoodItem[];
  analysisSummary?: string;
  foodName?: string;
  dishName?: string;
}

export type MealType = 'breakfast' | 'lunch' | 'dinner' | 'snack';

export interface MealDetailsType {
  id: number;
  time: string;
  name: string;
  status: 'upcoming' | 'completed';
  description?: string;
  foods?: string[];
  calories?: number;
  protein?: number;
  carbs?: number;
  fat?: number;
}

interface MealDetailsModalProps {
  meal: MealDetailsType;
  onMealCompleted: (mealId: number) => void;
  onUndoMealCompleted?: (mealId: number) => void;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  className?: string;
}

const MealDetailsModal: React.FC<MealDetailsModalProps> = ({ 
  meal, 
  onMealCompleted, 
  onUndoMealCompleted, 
  open, 
  onOpenChange, 
  className = "" 
}) => {
  const [alternativeDescription, setAlternativeDescription] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [analyzedMealData, setAnalyzedMealData] = useState<NutritionData | null>(null);
  const [isUndoing, setIsUndoing] = useState(false);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [hasJustAnalyzed, setHasJustAnalyzed] = useState(false); // Flag para rastrear se acaba de ser analisado
  
  // Fun√ß√£o para processar o resultado da an√°lise de IA
  const handleAnalysisComplete = (data: NutritionData) => {
    console.log('Resultado da an√°lise recebido:', data);
    setAnalyzedMealData(data);
    setHasJustAnalyzed(true);
    
    // Se h√° alimentos detectados, preencher o campo de texto
    if (data.foodItems && data.foodItems.length > 0) {
      const foodItems = data.foodItems.map(item => item.name);
      const descriptionText = foodItems.join(', ');
      setAlternativeFoodText(descriptionText);
      
      console.log('Campo de texto preenchido com alimentos detectados:', {
        foodItems,
        descriptionText
      });
    }
    
    // Salvar os dados permanentemente no localStorage para persistir entre recarregamentos
    try {
      // Salvar an√°lise da refei√ß√£o atual
      const mealAnalysisKey = `meal-analysis-${meal.id}`;
      localStorage.setItem(mealAnalysisKey, JSON.stringify({
        ...data,
        mealId: meal.id,
        mealType: meal.name,
        timestamp: new Date().toISOString()
      }));
      console.log(`An√°lise de ${meal.name} salva permanentemente no localStorage`)
      
      // Adicionar ao hist√≥rico de an√°lises
      const savedHistoryString = localStorage.getItem('all-meal-analyses') || '[]';
      const savedHistory = JSON.parse(savedHistoryString);
      
      // Adicionar √† lista e manter apenas as 20 √∫ltimas an√°lises
      savedHistory.unshift({
        ...data,
        mealId: meal.id,
        mealType: meal.name,
        timestamp: new Date().toISOString()
      });
      
      // Limitar a 20 itens para n√£o sobrecarregar o localStorage
      const updatedHistory = savedHistory.slice(0, 20);
      localStorage.setItem('all-meal-analyses', JSON.stringify(updatedHistory));
    } catch (error) {
      console.error('Erro ao salvar an√°lise no localStorage:', error);
    }
  };
  
  // Gerar sugest√µes de refei√ß√µes com base no tipo de refei√ß√£o e verificar dados da an√°lise
  // Usamos uma flag para evitar loops infinitos
  const [initialDataLoaded, setInitialDataLoaded] = useState(false);
  
  useEffect(() => {
    // S√≥ carregar os dados uma vez na montagem do componente
    if (!initialDataLoaded) {
      // Verificar se h√° dados de an√°lise recentes salvos
      const savedAnalysis = localStorage.getItem('current-meal-analysis');
      if (savedAnalysis) {
        try {
          const parsedAnalysis = JSON.parse(savedAnalysis);
          // Verificar se os dados s√£o recentes (menos de 5 minutos)
          const timestamp = new Date(parsedAnalysis.timestamp).getTime();
          const now = new Date().getTime();
          const fiveMinutesInMs = 5 * 60 * 1000;
          
          if (now - timestamp < fiveMinutesInMs) {
            console.log('Carregando dados da an√°lise recente:', parsedAnalysis);
            setAnalyzedMealData({
              calories: parsedAnalysis.calories || 0,
              protein: parsedAnalysis.protein || 0,
              carbs: parsedAnalysis.carbs || 0,
              fat: parsedAnalysis.fat || 0,
              fiber: 0,
              confidence: 1,
              foodItems: parsedAnalysis.foodItems || [],
              analysisSummary: parsedAnalysis.description
            });
            if (parsedAnalysis.description) {
              setAlternativeFoodText(parsedAnalysis.description);
            }
          } else {
            // Remover dados antigos
            localStorage.removeItem('current-meal-analysis');
            generateSuggestionsBasedOnMealType(meal.name);
          }
        } catch (e) {
          console.error('Erro ao carregar dados da an√°lise:', e);
          localStorage.removeItem('current-meal-analysis');
          generateSuggestionsBasedOnMealType(meal.name);
        }
      } else {
        generateSuggestionsBasedOnMealType(meal.name);
      }
      
      // Marcar que os dados iniciais foram carregados
      setInitialDataLoaded(true);
    }
  }, [meal.name, initialDataLoaded]);
  
  // Fun√ß√£o para gerar sugest√µes de alimentos com base no tipo de refei√ß√£o
  const generateSuggestionsBasedOnMealType = (mealType: string) => {
    let newSuggestions: string[] = [];
    
    // Caf√© da manh√£
    if (mealType.toLowerCase().includes('caf√©') || mealType.toLowerCase().includes('cafe')) {
      newSuggestions = [
        "2 ovos mexidos",
        "1 fatia de p√£o integral",
        "1 fruta",
        "Caf√© preto ou ch√° verde"
      ];
    }
    // Almo√ßo
    else if (mealType.toLowerCase().includes('almo√ßo') || mealType.toLowerCase().includes('almoco')) {
      newSuggestions = [
        "150g de prote√≠na (frango, peixe ou carne)",
        "2 colheres de arroz integral",
        "Feij√£o",
        "Salada verde",
        "Legumes ao vapor"
      ];
    }
    // Jantar
    else if (mealType.toLowerCase().includes('jantar')) {
      newSuggestions = [
        "150g de peixe assado",
        "Legumes vapor",
        "1 batata doce pequena",
        "Salada"  
      ];
    }
    // Lanche
    else if (mealType.toLowerCase().includes('lanche')) {
      newSuggestions = [
        "1 iogurte grego sem a√ß√∫car",
        "1 punhado de castanhas",
        "1 fruta m√©dia",
        "Ch√° de ervas"
      ];
    }
    
    setSuggestions(newSuggestions);
  };

  const handleCompleteMeal = async () => {
    try {
      setIsSubmitting(true);
      
      // Adicionar bot√£o de debug √† interface
      createDebugButton();
      
      // Registrar evento de in√≠cio da confirma√ß√£o
      trackDebugEvent('meal_confirmation', 'start', {
        mealId: meal.id,
        mealName: meal.name,
        mealStatus: meal.status,
        hasAnalyzedData: !!analyzedMealData
      });
      
      let mealCalories = analyzedMealData?.calories || meal.calories || 0;
      let mealProtein = analyzedMealData?.protein || meal.protein || 0;
      let mealCarbs = analyzedMealData?.carbs || meal.carbs || 0;
      let mealFat = analyzedMealData?.fat || meal.fat || 0;
      
      // Se n√£o houver calorias definidas, mas estamos confirmando usando as sugest√µes,
      // atribuir valores padr√£o de calorias com base no tipo de refei√ß√£o
      if (mealCalories <= 0) {
        const mealType = meal.name.toLowerCase();
        if (mealType.includes('caf√©')) {
          mealCalories = 350; // Caf√© da manh√£ padr√£o
          mealProtein = 15;
          mealCarbs = 45;
          mealFat = 12;
        } else if (mealType.includes('almo√ßo')) {
          mealCalories = 650; // Almo√ßo padr√£o
          mealProtein = 30;
          mealCarbs = 75;
          mealFat = 20;
        } else if (mealType.includes('jantar')) {
          mealCalories = 450; // Jantar padr√£o
          mealProtein = 25;
          mealCarbs = 50;
          mealFat = 15;
        } else {
          mealCalories = 200; // Lanche/snack padr√£o
          mealProtein = 10;
          mealCarbs = 25;
          mealFat = 8;
        }
        console.log(`N√£o h√° calorias definidas, usando valores padr√£o para ${mealType}: ${mealCalories} kcal`);
      }
      
      // Adiciona os alimentos da an√°lise ou usa os existentes
      let mealFoods = [];
      
      console.log('Determinando alimentos consumidos:');
      console.log('- AnalyzedMealData:', analyzedMealData?.foodItems?.map(item => item.name));
      console.log('- AlternativeFoodText:', alternativeFoodText);
      console.log('- Meal.foods:', meal.foods);
      
      // IMPORTANTE: Verifica explicitamente se os dados s√£o provenientes de uma an√°lise real
      const currentMealAnalysis = localStorage.getItem('current-meal-analysis');
      const isFromAIAnalysis = analyzedMealData && currentMealAnalysis !== null;
      
      debugLog('Depura√ß√£o de Alimentos Consumidos', {
        isFromAIAnalysis,
        currentMealAnalysis: currentMealAnalysis ? JSON.parse(currentMealAnalysis) : null,
        analyzedMealData,
        alternativeFoodText,
        mealFoods: meal.foods
      }, true);
      
      trackDebugEvent('meal_foods_detection', 'analysis_check', {
        isFromAIAnalysis,
        hasAnalyzedData: !!analyzedMealData,
        hasFoodItems: analyzedMealData?.foodItems?.length > 0,
        hasAlternativeText: !!alternativeFoodText,
        currentMealAnalysisExists: currentMealAnalysis !== null
      });
      
      // Priorizar alimentos detectados na an√°lise - Com prioridade absoluta caso seja de IA
      if (analyzedMealData?.foodItems && analyzedMealData.foodItems.length > 0) {
        const foodItems = analyzedMealData.foodItems.map(item => item.name);
        debugLog('Usando alimentos da an√°lise de IA', foodItems, true);
        trackDebugEvent('meal_foods_detection', 'using_ai_analysis', { foodItems });
        mealFoods = foodItems;
      } 
      // Se n√£o houver an√°lise, mas o usu√°rio digitou algo, usar isso
      else if (alternativeFoodText && alternativeFoodText.trim() !== '') {
        const foodItems = alternativeFoodText.split(',').map(item => item.trim()).filter(item => item !== '');
        debugLog('Usando alimentos do campo de texto', foodItems, true);
        trackDebugEvent('meal_foods_detection', 'using_text_input', { foodItems });
        mealFoods = foodItems;
      } 
      // Por √∫ltimo, usar os alimentos existentes da refei√ß√£o se houver
      else if (meal.foods && meal.foods.length > 0) {
        debugLog('Usando alimentos existentes da refei√ß√£o', meal.foods, true);
        trackDebugEvent('meal_foods_detection', 'using_existing_foods', { foodItems: meal.foods });
        mealFoods = [...meal.foods];
      }
      
      // MODIFICADO: Somente usar alimentos padr√£o se n√£o for uma an√°lise de IA e n√£o houver alimentos informados
      if (!isFromAIAnalysis && mealFoods.length === 0) {
        console.log('Sem alimentos detectados, usando valores padr√£o baseados no tipo de refei√ß√£o');
        const mealType = meal.name.toLowerCase();
        
        if (mealType.includes('caf√©')) {
          mealFoods = ['Caf√© com leite', 'P√£o integral com queijo', 'Banana'];
        } else if (mealType.includes('almo√ßo')) {
          mealFoods = ['Arroz integral', 'Feij√£o', 'Peito de frango grelhado', 'Salada verde'];
        } else if (mealType.includes('jantar')) {
          mealFoods = ['Sopa de legumes', 'Omelete', 'Ch√° de camomila'];
        } else {
          mealFoods = ['Iogurte natural', 'Granola', 'Fruta fresca'];
        }
      }
      
      // Usa o texto que o usu√°rio digitou ou mant√©m a descri√ß√£o original
      let mealDescription = '';
      if (alternativeFoodText && alternativeFoodText.trim() !== '') {
        mealDescription = alternativeFoodText.trim();
        // Adiciona os alimentos manualmente especificados se n√£o vier da an√°lise
        if (mealFoods.length === 0 && mealDescription) {
          mealFoods = mealDescription.split(',').map(item => item.trim());
        }
      } else if (analyzedMealData?.analysisSummary) {
        mealDescription = analyzedMealData.analysisSummary;
      } else if (meal.description) {
        mealDescription = meal.description;
      }

      // Adicionar calorias ao contador - SEMPRE adicionar quando confirmar a refei√ß√£o
      // Independente se veio da an√°lise ou da confirma√ß√£o manual
      let updatedCalorieData = null;
      if (mealCalories > 0) {
        try {
          // IMPORTANTE: Vamos sempre adicionar as calorias ao confirmar a refei√ß√£o
          // pois essa √© a confirma√ß√£o final do usu√°rio
          console.log(`Adicionando ${mealCalories} calorias ao contador...`);
          
          // Adicionar as calorias ao contador usando o servi√ßo
          updatedCalorieData = addConsumedCalories(mealCalories);
          console.log(`Adicionadas ${mealCalories} calorias ao contador. Novo total: ${updatedCalorieData.consumedCalories}`);
          
          // For√ßar a atualiza√ß√£o da interface do contador de calorias
          if (typeof forceUpdateCalorieCounter === 'function') {
            forceUpdateCalorieCounter();
          }
          
          // IMPORTANTE: For√ßar a atualiza√ß√£o imediata atrav√©s de um evento
          const event = new CustomEvent('meal-completed', {
            detail: { 
              mealId: meal.id,
              calories: mealCalories,
              foods: mealFoods,
              timestamp: new Date().toISOString()
            }
          });
          window.dispatchEvent(event);
          
          // For√ßar atualiza√ß√£o via localStorage tamb√©m (backup se o servi√ßo falhar)
          const currentCalories = localStorage.getItem('nutri-mindflow-calories') || '0';
          const newCalories = parseInt(currentCalories) + mealCalories;
          localStorage.setItem('nutri-mindflow-calories', newCalories.toString());
          
          // Emitir outro evento para for√ßar atualiza√ß√£o de todos os componentes
          const updateEvent = new CustomEvent('calories-updated', { 
            detail: { calories: newCalories } 
          });
          window.dispatchEvent(updateEvent);
        } catch (calorieError) {
          console.error('Erro ao adicionar calorias ao contador:', calorieError);
          // Fallback se o servi√ßo falhar
          try {
            const currentCalories = localStorage.getItem('nutri-mindflow-calories') || '0';
            const newCalories = parseInt(currentCalories) + mealCalories;
            localStorage.setItem('nutri-mindflow-calories', newCalories.toString());
            console.log('Calorias adicionadas via fallback localStorage:', newCalories);
          } catch (e) {
            console.error('Erro total ao adicionar calorias:', e);
          }
        }
      } else {
        console.warn('Nenhuma caloria para adicionar - valor √© zero ou negativo');
      }

      // Notificar o componente pai que a refei√ß√£o foi conclu√≠da
      // e passar os dados atualizados
      const updatedMeal = {
        ...meal,
        calories: mealCalories,
        protein: mealProtein,
        carbs: mealCarbs,
        fat: mealFat,
        foods: mealFoods,
        description: mealDescription
      };
      
      // Tentar salvar os dados no servi√ßo de hist√≥rico de alimentos
      try {
        // Se o servi√ßo de hist√≥rico de alimentos estiver dispon√≠vel
        if (typeof foodHistoryService?.saveAnalysis === 'function') {
          // Obter o ID do usu√°rio atual, ou usar um UUID v4 se n√£o estiver dispon√≠vel
          const userId = localStorage.getItem('user-id') || 'anonymous';
          
          const foodHistoryData = {
            mealId: meal.id.toString(),
            userId: userId,
            mealType: meal.name.toLowerCase(),
            description: mealDescription,
            calories: mealCalories,
            protein: mealProtein,
            carbs: mealCarbs,
            fat: mealFat,
            // Adicionar campos obrigat√≥rios para o tipo FoodAnalysisResult
            fiber: 0, // valor padr√£o
            confidence: 0.9, // valor padr√£o alto para confirma√ß√£o manual
            foodItems: mealFoods.map(food => ({ 
              name: food,
              calories: Math.round(mealCalories / mealFoods.length), // distribui as calorias
              portion: "1 por√ß√£o" // valor padr√£o para a por√ß√£o
            })),
            timestamp: new Date().toISOString(),
            analysisSummary: mealDescription,
            foodName: mealFoods.join(', '), // junta todos os alimentos como nome
            dishName: meal.name, // nome da refei√ß√£o como nome do prato
            id: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) // Gerando um ID √∫nico para este registro
          };
          
          // Registrar o que est√° sendo salvo no hist√≥rico para depura√ß√£o
          debugLog('Dados a serem salvos no hist√≥rico', {
            foodHistoryData,
            mealFoods,
            originalAnalysis: analyzedMealData,
            alternativeFoodText
          }, true);
          
          trackDebugEvent('meal_history_save', 'save_attempt', {
            mealType: meal.name,
            foodCount: mealFoods.length,
            foodItems: mealFoods,
            calories: mealCalories,
            fromAIAnalysis: !!analyzedMealData?.foodItems?.length
          });
          
          try {
            await foodHistoryService.saveAnalysis(foodHistoryData);
            
            debugLog('Dados salvos com sucesso no hist√≥rico de alimentos', foodHistoryData, true);
            trackDebugEvent('meal_history_save', 'save_success', { id: foodHistoryData.id });
            
            // Salvar uma c√≥pia dos dados para depura√ß√£o
            localStorage.setItem('debug_last_saved_meal', JSON.stringify({
              savedAt: new Date().toISOString(),
              data: foodHistoryData
            }));
          } catch (apiError) {
            console.error('Erro ao chamar a API de salvamento:', apiError);
            trackDebugEvent('meal_history_save', 'save_error', { error: String(apiError) });
          }
        }
      } catch (saveError) {
        console.error('Erro ao salvar no hist√≥rico de alimentos:', saveError);
        trackDebugEvent('meal_history_save', 'unexpected_error', { error: String(saveError) });
        // N√£o interrompe o fluxo principal - apenas loga o erro
      }
      
      onMealCompleted(meal.id);
      
      toast.success(`${meal.name} marcado como conclu√≠do!`, {
        description: mealCalories > 0 ? `${mealCalories} calorias adicionadas ao seu di√°rio.` : undefined
      });
      
      // Limpar os dados da an√°lise ap√≥s confirmar
      setAnalyzedMealData(null);
      setAlternativeFoodText('');
      
      // Limpar dados salvos no localStorage
      localStorage.removeItem('current-meal-analysis');
      localStorage.removeItem('calories-already-added');
      
    } catch (error) {
      console.error('Erro ao completar refei√ß√£o:', error);
      toast.error('Erro ao marcar refei√ß√£o como conclu√≠da', {
        description: 'Ocorreu um problema ao processar sua solicita√ß√£o.'
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUndoComplete = async () => {
    if (!onUndoMealCompleted) return;

    try {
      setIsUndoing(true);
      onUndoMealCompleted(meal.id);

      toast(`${meal.name} desmarcado com sucesso`, {
        description: "A refei√ß√£o foi retornada para 'pendente'."
      });
    } catch (error) {
      console.error('Erro ao desfazer conclus√£o da refei√ß√£o:', error);
      toast('Erro ao desfazer', {
        description: 'N√£o foi poss√≠vel desfazer a conclus√£o da refei√ß√£o.'
      });
    } finally {
      setIsUndoing(false);
    }
  };

  const [showAnalyzer, setShowAnalyzer] = useState(false);
  const [alternativeFoodText, setAlternativeFoodText] = useState('');

  // Fun√ß√£o para for√ßar a atualiza√ß√£o do contador na interface
  const forceUpdateCalorieCounter = () => {
    // Despacha um evento personalizado que o CalorieTracker2 escuta
    const event = new CustomEvent('calories-updated', { 
      detail: { calories: Date.now() } // Usando timestamp para garantir que seja um valor novo
    });
    window.dispatchEvent(event);
    console.log('Evento calories-updated disparado para for√ßar atualiza√ß√£o do contador');
  };

  // Carregar dados quando o modal abrir
  useEffect(() => {
    if (open) {
      // Executar a√ß√µes ao abrir o modal, como carregar sugest√µes
      generateSuggestionsBasedOnMealType(meal.name);
      
      // Verificar se h√° uma an√°lise salva para esta refei√ß√£o
      const savedAnalysisKey = `meal-analysis-${meal.id}`;
      const savedAnalysis = localStorage.getItem(savedAnalysisKey);
      
      if (savedAnalysis) {
        try {
          const parsedAnalysis = JSON.parse(savedAnalysis);
          setAnalyzedMealData(parsedAnalysis);
        } catch (err) {
          console.error('Erro ao carregar an√°lise salva:', err);
        }
      }
    }
  }, [open, meal.id, meal.name]);
  
  return (
    <Dialog
      open={open} 
      onOpenChange={onOpenChange}
    >
      <DialogContent className={`max-w-md ${className}`}>
        <DialogHeader>
          <DialogTitle className="flex items-center">
            <div className="flex-1">{meal.name}</div>
            <Badge className="ml-2 bg-blue-100 text-blue-800 hover:bg-blue-200">
              <Clock className="h-3 w-3 mr-1" /> {meal.time}
            </Badge>
          </DialogTitle>
          <DialogDescription>
            {meal.description || `Detalhes da refei√ß√£o ${meal.name}`}
          </DialogDescription>
        </DialogHeader>

        <ScrollArea className="max-h-80 mt-4">
          <div className="space-y-4">
            {showAnalyzer ? (
              <div className="space-y-4">
                <div className="flex items-center justify-between mb-2">
                  <Button 
                    variant="outline" 
                    size="sm" 
                    className="flex items-center space-x-1 text-gray-700"
                    onClick={() => setShowAnalyzer(false)}
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-left">
                      <path d="m12 19-7-7 7-7"/>
                      <path d="M19 12H5"/>
                    </svg>
                    <span>Voltar</span>
                  </Button>
                  <h3 className="font-medium">Analisando sua refei√ß√£o</h3>
                  <div className="w-20"></div> {/* Espa√ßador para centralizar o t√≠tulo */}
                </div>
                <CalorieAnalyzer
                  onAnalysisComplete={(data) => {
                    const handleCompleteMeal = async () => {
                      if (isSubmitting) return;
                      setIsSubmitting(true);
                      
                      try {
                        // Capturar os dados usados para completar a refei√ß√£o
                        const description = alternativeFoodText || meal.description;
                        const completeTime = new Date().toISOString();
                        
                        // Criar objeto com dados da refei√ß√£o
                        const mealData = {
                          mealId: meal.id,
                          mealType: meal.name.toLowerCase(),
                          description,
                          completedAt: completeTime,
                        };
                        
                        debugLog('Dados da refei√ß√£o para completar', mealData);
                        
                        // Verificar se h√° dados de an√°lise 
                        const currentMealAnalysis = localStorage.getItem('current-meal-analysis');
                        let analysisData = null;
                        let hasAnalysisData = false;
                        
                        // Se tivermos dados da an√°lise, usar eles 
                        if (currentMealAnalysis) {
                          try {
                            analysisData = JSON.parse(currentMealAnalysis);
                            hasAnalysisData = true;
                            
                            debugLog('Dados da an√°lise encontrados', analysisData);
                            
                            // Salvar dados da an√°lise permanentemente
                            const mealAnalysisKey = `meal-analysis-${meal.id}-${new Date().toISOString().split('T')[0]}`;
                            localStorage.setItem(mealAnalysisKey, JSON.stringify({
                              ...analysisData,
                              mealId: meal.id,
                              mealType: meal.name,
                              timestamp: new Date().toISOString()
                            }));
                            
                            // Salvar tamb√©m no hist√≥rico de an√°lises
                            const existingHistory = localStorage.getItem('meal-analysis-history') || '[]';
                            try {
                              const historyArray = JSON.parse(existingHistory);
                              historyArray.unshift({
                                ...analysisData,
                                mealId: meal.id,
                                mealType: meal.name,
                                timestamp: new Date().toISOString()
                              });
                              // Manter apenas as √∫ltimas 20 an√°lises
                              const updatedHistory = historyArray.slice(0, 20);
                              localStorage.setItem('meal-analysis-history', JSON.stringify(updatedHistory));
                            } catch (e) {
                              console.error('Erro ao atualizar hist√≥rico de an√°lises:', e);
                            }
                          } catch (error) {
                            console.error('Erro ao processar dados da an√°lise:', error);
                          }
                        } else {
                          debugLog('Sem dados de an√°lise dispon√≠veis', null);
                        }
                        
                        // Atualizar os dados analisados
                        setAnalyzedMealData(data);
                        
                        // Criar uma descri√ß√£o para o campo "Comeu algo diferente"
                        let descriptionText = '';
                        
                        // Verificar se h√° uma an√°lise salva no localStorage
                        const savedAnalysis = localStorage.getItem('lastMealAnalysis');
                        if (savedAnalysis) {
                          try {
                            const parsedAnalysis = JSON.parse(savedAnalysis);
                            if (parsedAnalysis.description) {
                              descriptionText = parsedAnalysis.description;
                              console.log('Usando descri√ß√£o da an√°lise salva:', descriptionText);
                            } else if (parsedAnalysis.suggestedFoods && parsedAnalysis.suggestedFoods.length > 0) {
                              // Usar os alimentos sugeridos se estiverem dispon√≠veis
                              descriptionText = parsedAnalysis.suggestedFoods.join(', ');
                              console.log('Usando alimentos sugeridos da an√°lise salva:', descriptionText);
                            }
                            // Remover a an√°lise do localStorage ap√≥s usar
                            localStorage.removeItem('lastMealAnalysis');
                          } catch (e) {
                            console.error('Erro ao analisar lastMealAnalysis:', e);
                          }
                        } else {
                          // Extrair os alimentos detectados
                          if (data.foodItems && data.foodItems.length > 0) {
                            const foodItems = data.foodItems.map(item => item.name);
                            descriptionText = foodItems.join(', ');
                            console.log('Alimentos detectados:', foodItems);
                          }
                          // Usar a descri√ß√£o da an√°lise se dispon√≠vel
                          else if (data.analysisSummary) {
                            descriptionText = data.analysisSummary;
                          }
                          // Se ainda n√£o tiver descri√ß√£o, usar o nome do alimento
                          else if (data.foodName) {
                            descriptionText = data.foodName;
                          }
                        }
                        
                        console.log('Definindo texto alternativo:', descriptionText);
                        setAlternativeFoodText(descriptionText);
                        
                        // Adicionar calorias ao contador aqui mesmo
                        try {
                          if (data.calories && data.calories > 0) {
                            // Adicionar as calorias usando o servi√ßo
                            const updatedCalorieData = addConsumedCalories(data.calories);
                            console.log(`Adicionadas ${data.calories} calorias ao contador. Total: ${updatedCalorieData.consumedCalories}`);
                            
                            // For√ßar a atualiza√ß√£o da interface do contador
                            forceUpdateCalorieCounter();
                            
                            toast.success('Calorias adicionadas', {
                              description: `${data.calories} calorias foram adicionadas ao seu contador di√°rio.`
                            });
                          }
                        } catch (error) {
                          console.error('Erro ao adicionar calorias ap√≥s an√°lise:', error);
                        }
                        
                        // IMPORTANTE: Esconder o analisador e voltar para a tela principal
                        setTimeout(() => {
                          setShowAnalyzer(false);
                        }, 500); // Pequeno delay para garantir que a interface seja atualizada corretamente
                      };
                      handleCompleteMeal();
                        // Remover a an√°lise do localStorage ap√≥s usar
                        localStorage.removeItem('lastMealAnalysis');
                      } catch (e) {
                        console.error('Erro ao analisar lastMealAnalysis:', e);
                      }
                  presetMealType={meal.name}
                />
              </div>
            ) : (
              <>
                {/* Box superior com a descri√ß√£o da comida */}
                <div className="mb-4 p-3 rounded-md bg-gray-50 border border-gray-200">
                  <p className="text-sm text-gray-700">
                    {meal.description || `Op√ß√£o equilibrada e nutritiva para ${meal.name.toLowerCase()}.`}
                  </p>
                </div>
                
                {/* Sugest√µes de alimentos baseadas no hor√°rio */}
                {!analyzedMealData && suggestions.length > 0 && (
                  <div className="mb-4">
                    <h4 className="text-sm font-medium mb-2">Alimentos sugeridos:</h4>
                    <ul className="list-disc pl-5 text-sm space-y-1">
                      {suggestions.map((item, index) => (
                        <li key={index}>{item}</li>
                      ))}
                    </ul>
                  </div>
                )}

                {/* Alimentos consumidos - mostrar da an√°lise se dispon√≠vel ou da refei√ß√£o se completa */}
                {(() => {
                  // Verificar se h√° alimentos para exibir
                  const hasAnalyzedFoods = analyzedMealData?.foodItems && analyzedMealData.foodItems.length > 0;
                  const hasMealFoods = meal.status === 'completed' && meal.foods && meal.foods.length > 0;
                  
                  if (!hasAnalyzedFoods && !hasMealFoods) {
                    return null;
                  }
                  
                  return (
                    <div className="mb-4">
                      <h4 className="text-sm font-medium mb-2">Alimentos consumidos:</h4>
                      <ul className="list-disc pl-5 text-sm space-y-1">
                        {hasAnalyzedFoods && analyzedMealData?.foodItems ? 
                          // Mostrar alimentos detectados na an√°lise
                          analyzedMealData.foodItems.map((item, index) => (
                            <li key={`analyzed-${index}`}>{item.name}</li>
                          )) :
                          // Ou mostrar alimentos da refei√ß√£o completa
                          hasMealFoods && meal.foods ? 
                            meal.foods.map((food, index) => (
                              <li key={`meal-${index}`}>{food}</li>
                            )) : 
                            <li>Nenhum alimento detectado</li>
                        }
                      </ul>
                    </div>
                  );
                })()}

                {/* Boxes coloridos com informa√ß√µes nutricionais */}
                <div className="grid grid-cols-4 gap-2 mb-4">
                  <div className="p-3 bg-gray-50 rounded-md text-center">
                    <div className="text-lg font-semibold">
                      {analyzedMealData ? (
                        <span className="flex flex-col items-center">
                          <span className="text-lg">{analyzedMealData.calories || 0}</span>
                          {meal.calories && meal.calories !== analyzedMealData.calories && (
                            <span className="text-xs text-gray-400 line-through">{meal.calories}</span>
                          )}
                        </span>
                      ) : (
                        meal.calories || 450
                      )}
                    </div>
                    <div className="text-xs text-gray-500">kcal</div>
                  </div>
                  <div className="p-3 bg-green-50 rounded-md text-center">
                    <div className="text-lg font-semibold text-green-600">{analyzedMealData?.protein || meal.protein || 35}g</div>
                    <div className="text-xs text-green-600">Prote√≠nas</div>
                  </div>
                  <div className="p-3 bg-amber-50 rounded-md text-center">
                    <div className="text-lg font-semibold text-amber-600">{analyzedMealData?.carbs || meal.carbs || 45}g</div>
                    <div className="text-xs text-amber-600">Carboidratos</div>
                  </div>
                  <div className="p-3 bg-blue-50 rounded-md text-center">
                    <div className="text-lg font-semibold text-blue-600">{analyzedMealData?.fat || meal.fat || 15}g</div>
                    <div className="text-xs text-blue-600">Gorduras</div>
                  </div>
                </div>
                
                {/* Informa√ß√µes da an√°lise atual */}
                {analyzedMealData && hasJustAnalyzed && (
                  <div className="p-3 mb-4 bg-blue-50 border border-blue-100 rounded-md">
                    <h4 className="text-sm font-medium text-blue-800 mb-1">Resultado da an√°lise</h4>
                    <div className="text-xs text-blue-700">
                      <p>Esta refei√ß√£o cont√©m aproximadamente <strong>{analyzedMealData.calories} calorias</strong>.</p>
                      {analyzedMealData.foodItems && analyzedMealData.foodItems.length > 0 && (
                        <ul className="mt-1 pl-4 list-disc text-xs">
                          {analyzedMealData.foodItems.map((item, idx) => (
                            <li key={idx}>{item.name} {item.calories ? `(~${item.calories} kcal)` : ''}</li>
                          ))}
                        </ul>
                      )}
                    </div>
                  </div>
                )}

                <div className="my-6 space-y-6">
                  {meal.foods && meal.foods.length > 0 && (
                    <div>
                      <h3 className="text-base font-semibold mb-2">Alimentos sugeridos:</h3>
                      <ul className="space-y-1">
                        {meal.foods.map((food, index) => (
                          <li key={index} className="flex items-center space-x-2">
                            <div className="h-2 w-2 rounded-full bg-primary" />
                            <span>{food}</span>
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                  
                  <div>
                    <h3 className="text-base font-semibold mb-2">Comeu algo diferente?</h3>
                    {/* Mostrar mensagem apenas quando houver an√°lise recente */}
                    {analyzedMealData && hasJustAnalyzed && (
                      <div className="p-2 bg-green-50 text-green-800 text-sm rounded-md mb-2">
                        Foi registrar os alimentos. Estes alimentos ser√£o usados quando voc√™ confirmar a refei√ß√£o.
                      </div>
                    )}
                    <textarea 
                      value={alternativeFoodText}
                      onChange={(e) => setAlternativeFoodText(e.target.value)}
                      placeholder="Descreva o que voc√™ comeu..."
                      className="h-24 resize-none"
                    />
                  </div>
                  
                  {/* O analisador de calorias foi removido daqui, agora √© acessado apenas pelo bot√£o abaixo */}
                </div>

                <div className="mb-4">
                  <Button 
                    className="w-full bg-blue-600 hover:bg-blue-700 text-white py-3"
                    onClick={() => setShowAnalyzer(true)}
                  >
                    Analisar Outra Refei√ß√£o
                  </Button>
                </div>
              </>
            )}


            {/* Lista de alimentos j√° removida - estava duplicada */}
          </div>
        </ScrollArea>

        <DialogFooter className="mt-4">
          {meal.status === 'upcoming' ? (
            <Button 
              onClick={handleCompleteMeal} 
              className="bg-green-600 hover:bg-green-700"
              disabled={isSubmitting}
            >
              <Check className="h-4 w-4 mr-2" />
              Confirmar Refei√ß√£o
            </Button>
          ) : (
            <Button 
              variant="outline" 
              onClick={handleUndoComplete}
              disabled={isUndoing}
              className="text-amber-600 border-amber-300 hover:bg-amber-50"
            >
              Desfazer
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MealDetailsModal;
